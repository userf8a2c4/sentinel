import datetime as dt
import hashlib
import io
import math
from typing import Any

import matplotlib.pyplot as plt
import pandas as pd
import qrcode
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
from reportlab.lib.units import cm
from reportlab.pdfgen import canvas as reportlab_canvas
from reportlab.platypus import Image, Paragraph, SimpleDocTemplate, Spacer, Table, TableStyle


class ReportCanvas(reportlab_canvas.Canvas):
    def __init__(self, *args, footer_data: dict[str, str] | None = None, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._saved_page_states: list[dict[str, Any]] = []
        self._footer_data = footer_data or {}

    def showPage(self) -> None:
        self._saved_page_states.append(dict(self.__dict__))
        self._startPage()

    def save(self) -> None:
        total_pages = len(self._saved_page_states)
        for state in self._saved_page_states:
            self.__dict__.update(state)
            self._draw_footer(total_pages)
            super().showPage()
        super().save()

    def _draw_footer(self, total_pages: int) -> None:
        page = self.getPageNumber()
        root_hash = self._footer_data.get("root_hash", "")
        page_payload = f"{root_hash}|{page}"
        page_hash = hashlib.sha256(page_payload.encode("utf-8")).hexdigest()[:12]
        self.setFont("Helvetica", 8)
        self.setFillColor(colors.HexColor("#94A3B8"))
        self.drawString(1.5 * cm, 0.75 * cm, "Generated by Centinel Engine v5")
        self.drawRightString(
            self._pagesize[0] - 1.5 * cm,
            0.75 * cm,
            f"Página {page}/{total_pages}",
        )
        self.setFont("Courier", 7)
        self.drawString(1.5 * cm, 0.45 * cm, f"Page hash: {page_hash}")


class CentinelPDFReport:
    def __init__(self) -> None:
        self.palette = {
            "navy": colors.HexColor("#0B1F3B"),
            "slate": colors.HexColor("#1F2937"),
            "alert": colors.HexColor("#D62728"),
            "emerald": colors.HexColor("#10B981"),
            "muted": colors.HexColor("#94A3B8"),
            "text": colors.HexColor("#0F172A"),
            "bg": colors.HexColor("#F8FAFC"),
        }

    def generate(self, data: dict[str, Any], filename: str) -> None:
        report_time = self._parse_timestamp(data.get("timestamp_utc"))
        root_hash = str(data.get("root_hash", "N/A"))
        status = str(data.get("status", "INTEGRAL")).upper()
        status_color = self.palette["emerald"] if status == "INTEGRAL" else self.palette["alert"]
        status_label = "STATUS: INTEGRAL" if status == "INTEGRAL" else "STATUS: COMPROMETIDO"

        doc = SimpleDocTemplate(
            filename,
            pagesize=A4,
            leftMargin=1.8 * cm,
            rightMargin=1.8 * cm,
            topMargin=1.8 * cm,
            bottomMargin=1.8 * cm,
        )
        styles = self._build_styles()
        elements: list[Any] = []

        elements.extend(
            self._build_header(
                styles,
                status_label,
                status_color,
                report_time,
                root_hash,
                str(data.get("source", "Endpoint N/A")),
            )
        )

        elements.append(Spacer(1, 8))
        elements.append(Paragraph("Integridad Topológica", styles["Heading"]))
        topology = data.get("topology_check", {})
        elements.append(self._build_topology_section(styles, topology))

        elements.append(Spacer(1, 12))
        elements.append(Paragraph("Mapa de Calor Geoespacial", styles["Heading"]))
        heatmap = self._render_heatmap(data.get("anomalies", []))
        if heatmap is not None:
            elements.append(Image(heatmap, width=doc.width, height=7 * cm))
            elements.append(Paragraph("Anomalías por departamento y hora.", styles["Body"]))
        else:
            elements.append(Paragraph("No hay datos suficientes para el heatmap.", styles["Body"]))

        elements.append(Spacer(1, 12))
        elements.append(Paragraph("Análisis de Benford", styles["Heading"]))
        benford = self._render_benford(data)
        if benford is not None:
            elements.append(Image(benford, width=doc.width, height=7 * cm))
            elements.append(
                Paragraph(
                    "Comparación real vs esperado con banda de confianza 95%.",
                    styles["Body"],
                )
            )
        else:
            elements.append(Paragraph("Sin datos suficientes para Benford.", styles["Body"]))

        elements.append(Spacer(1, 12))
        elements.append(Paragraph("Cadena de Bloques (Snapshots)", styles["Heading"]))
        chain = self._render_chain(data.get("snapshots", []))
        if chain is not None:
            elements.append(Image(chain, width=doc.width, height=4.8 * cm))

        elements.append(Spacer(1, 12))
        elements.append(Paragraph("Verificación QR", styles["Heading"]))
        qr_payload = f"{root_hash}|{report_time.isoformat()}"
        qr_img = self._render_qr(qr_payload)
        if qr_img is not None:
            elements.append(Image(qr_img, width=3.2 * cm, height=3.2 * cm))
            elements.append(Paragraph("Escanee para validar el hash raíz.", styles["Body"]))

        footer_data = {"root_hash": root_hash}
        doc.build(
            elements,
            canvasmaker=lambda *args, **kwargs: ReportCanvas(
                *args, footer_data=footer_data, **kwargs
            ),
        )

    def _build_styles(self) -> dict[str, ParagraphStyle]:
        styles = getSampleStyleSheet()
        styles.add(
            ParagraphStyle(
                name="Heading",
                fontName="Helvetica-Bold",
                fontSize=12,
                leading=15,
                textColor=self.palette["navy"],
                spaceAfter=6,
            )
        )
        styles.add(
            ParagraphStyle(
                name="Body",
                fontName="Helvetica",
                fontSize=9.5,
                leading=12,
                textColor=self.palette["text"],
            )
        )
        styles.add(
            ParagraphStyle(
                name="Mono",
                fontName="Courier",
                fontSize=8.5,
                leading=10,
                textColor=self.palette["text"],
            )
        )
        styles.add(
            ParagraphStyle(
                name="Alert",
                fontName="Helvetica-Bold",
                fontSize=9.5,
                leading=12,
                textColor=self.palette["alert"],
            )
        )
        return styles

    def _build_header(
        self,
        styles: dict[str, ParagraphStyle],
        status_label: str,
        status_color: colors.Color,
        report_time: dt.datetime,
        root_hash: str,
        source: str,
    ) -> list[Any]:
        title = Paragraph("CENTINEL INTEGRITY REPORT", styles["Heading"])
        meta_rows = [
            ["Timestamp UTC", report_time.strftime("%Y-%m-%d %H:%M:%S UTC")],
            ["Hash Raíz", root_hash],
            ["Fuente de Datos", source],
        ]
        meta_table = Table(meta_rows, colWidths=[3.5 * cm, 12.5 * cm])
        meta_table.setStyle(
            TableStyle(
                [
                    ("FONT", (0, 0), (-1, -1), "Helvetica"),
                    ("FONTSIZE", (0, 0), (-1, -1), 9),
                    ("TEXTCOLOR", (0, 0), (-1, -1), self.palette["text"]),
                    ("BACKGROUND", (0, 0), (-1, -1), self.palette["bg"]),
                    ("LINEBELOW", (0, 0), (-1, -1), 0.25, self.palette["muted"]),
                    ("FONT", (1, 0), (1, 1), "Courier"),
                ]
            )
        )
        badge = Table([[status_label]], colWidths=[6 * cm])
        badge.setStyle(
            TableStyle(
                [
                    ("BACKGROUND", (0, 0), (-1, -1), status_color),
                    ("TEXTCOLOR", (0, 0), (-1, -1), colors.white),
                    ("ALIGN", (0, 0), (-1, -1), "CENTER"),
                    ("FONT", (0, 0), (-1, -1), "Helvetica-Bold"),
                    ("FONTSIZE", (0, 0), (-1, -1), 9),
                    ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                ]
            )
        )
        header_table = Table(
            [[title, badge], [meta_table, ""]], colWidths=[12 * cm, 5 * cm]
        )
        header_table.setStyle(
            TableStyle(
                [
                    ("VALIGN", (0, 0), (-1, -1), "TOP"),
                    ("ALIGN", (1, 0), (1, 0), "RIGHT"),
                    ("SPAN", (0, 1), (1, 1)),
                ]
            )
        )
        return [header_table]

    def _build_topology_section(
        self, styles: dict[str, ParagraphStyle], topology: dict[str, Any]
    ) -> Any:
        national_total = float(topology.get("total_national", topology.get("national_total", 0)))
        dept_total = float(topology.get("department_total", 0))
        delta = national_total - dept_total
        is_match = topology.get("is_match", national_total == dept_total)

        text_style = styles["Body"] if is_match else styles["Alert"]
        summary = (
            "Consistencia confirmada entre total nacional y suma departamental."
            if is_match
            else f"DISCREPANCIA: diferencia de {delta:,.0f} votos entre total nacional y departamental."
        )
        items: list[Any] = [Paragraph(summary, text_style)]
        if not is_match:
            waterfall = self._render_waterfall(dept_total, national_total)
            if waterfall is not None:
                items.append(Spacer(1, 6))
                items.append(Image(waterfall, width=12 * cm, height=5.5 * cm))
        return Table([[item] for item in items], colWidths=[16.5 * cm])

    def _render_waterfall(self, dept_total: float, national_total: float) -> io.BytesIO | None:
        delta = national_total - dept_total
        fig, ax = plt.subplots(figsize=(6, 2.4))
        ax.bar([0], [dept_total], color="#1F77B4")
        ax.bar([1], [delta], bottom=[dept_total], color="#D62728")
        ax.bar([2], [national_total], color="#10B981")
        ax.set_xticks([0, 1, 2], ["Departamentos", "Δ", "Nacional"])
        ax.set_ylabel("Votos")
        ax.set_title("Waterfall de discrepancia")
        ax.spines[["top", "right"]].set_visible(False)
        buf = io.BytesIO()
        fig.tight_layout()
        fig.savefig(buf, format="png", dpi=300)
        plt.close(fig)
        buf.seek(0)
        return buf

    def _render_heatmap(self, anomalies: list[dict[str, Any]]) -> io.BytesIO | None:
        if not anomalies:
            return None
        df = pd.DataFrame(anomalies)
        if df.empty or "department" not in df.columns or "hour" not in df.columns:
            return None
        pivot = (
            df.pivot_table(
                index="department",
                columns="hour",
                values="anomaly",
                aggfunc="count",
                fill_value=0,
            )
            .sort_index()
            .sort_index(axis=1)
        )
        fig, ax = plt.subplots(figsize=(7, 3))
        im = ax.imshow(pivot.values, cmap="Reds")
        ax.set_xticks(range(len(pivot.columns)), pivot.columns)
        ax.set_yticks(range(len(pivot.index)), pivot.index)
        ax.set_xlabel("Hora")
        ax.set_ylabel("Departamento")
        fig.colorbar(im, ax=ax, fraction=0.03, pad=0.02)
        fig.tight_layout()
        buf = io.BytesIO()
        fig.savefig(buf, format="png", dpi=300)
        plt.close(fig)
        buf.seek(0)
        return buf

    def _render_benford(self, data: dict[str, Any]) -> io.BytesIO | None:
        benford = data.get("benford", {})
        observed = benford.get("observed")
        sample_size = benford.get("sample_size")
        if observed is None:
            values = data.get("time_series", {}).get("values", [])
            observed = self._compute_first_digit(values)
            sample_size = len(values)
        if not observed:
            return None

        digits = list(range(1, 10))
        expected = [self._benford_prob(d) for d in digits]
        observed = observed[:9]
        if sample_size is None:
            sample_size = max(int(sum(observed)), 1)
        ci = [1.96 * ((p * (1 - p) / sample_size) ** 0.5) for p in expected]
        upper = [p + margin for p, margin in zip(expected, ci)]
        lower = [p - margin for p, margin in zip(expected, ci)]

        fig, ax = plt.subplots(figsize=(7, 3))
        bars = ax.bar(digits, observed, color="#1F77B4", alpha=0.85)
        ax.plot(digits, expected, color="#10B981", marker="o", label="Esperado")
        ax.fill_between(digits, lower, upper, color="#94A3B8", alpha=0.3, label="95% CI")
        for idx, bar in enumerate(bars):
            if observed[idx] < lower[idx] or observed[idx] > upper[idx]:
                bar.set_color("#D62728")
        ax.set_xlabel("Dígito")
        ax.set_ylabel("Frecuencia")
        ax.set_title("Benford: Observado vs Esperado")
        ax.legend(loc="upper right")
        fig.tight_layout()
        buf = io.BytesIO()
        fig.savefig(buf, format="png", dpi=300)
        plt.close(fig)
        buf.seek(0)
        return buf

    def _render_chain(self, snapshots: list[dict[str, Any]]) -> io.BytesIO | None:
        if not snapshots:
            return None
        recent = snapshots[-5:]
        labels = [str(item.get("hash", ""))[:8] for item in recent]
        fig, ax = plt.subplots(figsize=(7, 1.8))
        ax.axis("off")
        for idx, label in enumerate(labels):
            x = idx * 1.4
            ax.add_patch(plt.Rectangle((x, 0.4), 1.1, 0.6, color="#1F2937", alpha=0.9))
            ax.text(x + 0.55, 0.7, label, color="white", ha="center", va="center", fontsize=8)
            if idx < len(labels) - 1:
                ax.annotate(
                    "",
                    xy=(x + 1.2, 0.7),
                    xytext=(x + 1.35, 0.7),
                    arrowprops=dict(arrowstyle="->", color="#10B981"),
                )
        ax.set_xlim(-0.2, len(labels) * 1.4)
        ax.set_ylim(0, 1.5)
        fig.tight_layout()
        buf = io.BytesIO()
        fig.savefig(buf, format="png", dpi=300, transparent=True)
        plt.close(fig)
        buf.seek(0)
        return buf

    def _render_qr(self, payload: str) -> io.BytesIO | None:
        if not payload:
            return None
        buffer = io.BytesIO()
        qr = qrcode.QRCode(box_size=4, border=2)
        qr.add_data(payload)
        qr.make(fit=True)
        img = qr.make_image(fill_color="black", back_color="white")
        img.save(buffer, format="PNG")
        buffer.seek(0)
        return buffer

    def _compute_first_digit(self, values: list[Any]) -> list[float]:
        digits = []
        for value in values:
            try:
                value_str = str(int(abs(float(value))))
            except (ValueError, TypeError):
                continue
            if value_str and value_str != "0":
                digits.append(int(value_str[0]))
        if not digits:
            return []
        counts = pd.Series(digits).value_counts().sort_index()
        total = counts.sum()
        return [(counts.get(d, 0) / total) for d in range(1, 10)]

    def _benford_prob(self, digit: int) -> float:
        return math.log10(1 + 1 / digit)

    def _parse_timestamp(self, value: Any) -> dt.datetime:
        if isinstance(value, dt.datetime):
            return value.astimezone(dt.timezone.utc)
        if isinstance(value, str):
            try:
                return dt.datetime.fromisoformat(value.replace("Z", "+00:00"))
            except ValueError:
                pass
        return dt.datetime.now(dt.timezone.utc)
